/*
* ПРИНЦИП РАБОТЫ АЛГОРИТМА
* Работа программы разделена на 2 части:
*	- функция обработки входных данных processingData
*	- класс DequeSized реализующий заданный условиями задачи функционал
*
* Ф-ция processingData принимает два потока (по умолчанию стандартные cin и cout).
*	Это позволяет производить тестирование в более удобном формате.
*	Далее функция считывает количество команд и размер Дека, и вызывает
*	соответствующий метод DequeSized для кождой из команд.
*
* (класс DequeSized не расчитан на расширение функционала)
* Класс DequeSized реализован на основе вектора целыХ чисел (int16_t)
*		тк значения в деке не привосходят по модулю 1000 для экономии
*		памяти используется int16_t (2 байта signed - от -32 768 до 32 767)
*		согласно с условиями задачи самих данных будет храниться max 2 * 50'000 = 0.1Mb
*		+ некоторое количество памяти занимаемое контейнером vector
* В классе также хранится значение ёмкости дека(макс. размер дека - _capacity),
*	размер дека(_size), индекс "головы" (_head) и "хвоста" (_tail) дека.
*	Все - беззнаковые целые (size_t - занимает от 2х до 4х байт, в завис. от проца)
*	Ввиду их небольшого количества и размера ими можно пренебречь.
* Дек реализован как закольцованный вектор. Преремещение "головы" и "хвоста" дека
*	происходит по кругу на один элемент по часовой (приватный метод turnRight) и
*	против часовой (приватный метод turnLeft) стрелки.
*		turnRight - прибавляет 1 к индексу элемента, оставляя индекс в пределах _capacity
*		turnLeft  - отнимает 1 от индекса элемента. Индекс элемента - беззнаковый,
*			необходима проверка на достижение им "0"(начала вектора).
*
* При добавлении элемента в конец (push_back) дека - переданное в метод значение элемента
* вставляется в хвост (_tail), индекс хвоста сдвигается по часовой стрелке (turnRight).
* Увеличиваем размер (_size) дека.
* При добавлении элемента в начало (push_front) дека - переданное в метод значение элемента
* вставляется в голову (_head), индекс головы сдвигается против часовой стрелки (turnLeft).
* Увеличиваем размер (_size) дека.
*
* При удалении элемента из конца (pop_back) дека - двигаем хвост против часовой (turnLeft)
* (тк хвост сейчас указывал на "мусорные" данные - место для вставки нового элемента).
* Выводим элемент в поток. Уменьшаем размер (_size) дека.
* При удалении элемента из начала (pop_front) дека - двигаем голову (_head) по часовой (turnRight)
* (тк голова сейчас указывала на "мусорные" данные - место для вставки нового элемента).
* Выводим элемент в поток. Уменьшаем размер (_size) дека.
*
* При инициализации:
*		_capacity - устанавливается в соответсвии со считанным из потока замером дека.
*		_size - считаем чтоэлементов в деке нет - 0.
*		_head, _tail - "голова" и "хвост" имеют один индекс - 0.
*		_data - сам "дек" - создаем один раз по заданному размеру.
* В каждом методе проверяются соответствующие крайние точки.
*	push_back и push_front
*		- превыщение ёмкости дека (_size == _capacity) - не заполнен ли
*		- "голова" и "хвост" стоят на одном индексе и есть куда их двигать:
*			может быть при вставке первого эл-та в дек
*			или после удаления всех эл-тов из дека.
*			push_back - двигаем голову, push_front - двигаем хвост.
*	pop_front и pop_front
*		- пустоты дека (_size == 0)
* Все публичные методы отвечают за вывод сообщения об ошибке "error".
*	Для удобства тестирования поток передается в методы как параметр,
*	и по умолчанию это установлен поток std::cout
*/

// Вычислительная сложность алгоритма
// Инициализация O(n) - n - размер дека
// Методы дека - O(1)

// int16_t - 2B (байта) signed	- от -32 768 до 32 767
// Пространственная сложность алгоритма
// некоторое количество места занимет контейнер vector<int16_t>
// В целом можно сказать что DequeSized занимает фиксированный объем памяти
// зависящий как O(n) - n - размер дека 
// (n*int16_t + const = n*2B + const, где const - это vector + 4*size_t)
// (const << n * int16_t)
